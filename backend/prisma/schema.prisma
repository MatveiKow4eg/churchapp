generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
  SUPERADMIN
}

enum UserStatus {
  ACTIVE
  BANNED
}

enum TaskCategory {
  SPIRITUAL
  SERVICE
  COMMUNITY
  CREATIVITY
  REFLECTION
  OTHER
}

enum XpCategory {
  SPIRITUAL
  SERVICE
  COMMUNITY
  CREATIVITY
  REFLECTION
  OTHER
}


enum XpSource {
  TASK
  STREAK
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELED
}

enum LedgerType {
  TASK_REWARD
  PURCHASE
  ADMIN_ADJUSTMENT
}

// Shop items are now code-driven on the client (catalog.json).
// Server stores only pricing/active flags per church and purchase facts.

// Минимальная тестовая модель для проверки миграций.
model HealthPing {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
}

// Church — минимальная модель только для связи с User.
// Не расширяем бизнес-логику на этом шаге.
model Church {
  id            String            @id @default(cuid())
  name          String            @unique
  city          String?
  users         User[]
  tasks         Task[]
  submissions   Submission[]
  ledgerEntries PointsLedger[]
  shopCatalog   ShopCatalogItem[]
  createdAt     DateTime          @default(now())
}

model User {
  id        String     @id @default(cuid())
  firstName String
  lastName  String
  age       Int
  city      String

  // Auth
  // Nullable for backward-compatible migration (existing users).
  email        String?  @unique
  passwordHash String?

  role      UserRole   @default(USER)
  status    UserStatus @default(ACTIVE)

  churchId String?
  church   Church? @relation(fields: [churchId], references: [id], onDelete: SetNull)

  submissions   Submission[]
  ledgerEntries PointsLedger[]
  inventory     Inventory[]

  avatarConfig    Json?
  avatarUpdatedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([churchId])
  @@index([lastName])

  // --- XP / Level system ---
  level               Int      @default(1)
  levelXp             Int      @default(0)

  // XP per category (current level, resets on level-up)
  xpSpiritual         Int      @default(0)
  xpService           Int      @default(0)
  xpCommunity         Int      @default(0)
  xpCreativity        Int      @default(0)
  xpReflection        Int      @default(0)
  xpOther             Int      @default(0)

  // Streak tracking (hidden bonus logic)
  streakDays          Int      @default(0)
  lastTaskCompletedAt DateTime?

  // Lifetime stats (never reset)
  lifetimeXp          Int      @default(0)
  lifetimeXpSpiritual Int      @default(0)
  lifetimeXpService   Int      @default(0)
  lifetimeXpCommunity Int      @default(0)
  lifetimeXpCreativity Int     @default(0)
  lifetimeXpReflection Int     @default(0)
  lifetimeXpOther     Int      @default(0)

  xpLedger XpLedger[]
}

model Task {
  id String @id @default(cuid())

  churchId String
  church   Church @relation(fields: [churchId], references: [id], onDelete: Cascade)

  title        String
  description  String
  category     TaskCategory @default(OTHER)
  pointsReward Int

  isActive Boolean @default(true)

  // пока просто поле (без relation на User)
  createdById String?

  submissions Submission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([churchId])
  @@index([isActive])
  @@index([category])

  xpLedger XpLedger[]
}

model Submission {
  id String @id @default(cuid())

  churchId String
  church   Church @relation(fields: [churchId], references: [id], onDelete: Cascade)

  taskId String
  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  status SubmissionStatus @default(PENDING)

  commentUser  String?
  commentAdmin String?

  decidedAt   DateTime?
  decidedById String?

  rewardPointsApplied Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([churchId])
  @@index([taskId])
  @@index([userId])
  @@index([status])

  // allow multiple attempts per (userId, taskId)
  @@index([userId, taskId, createdAt])

  // XP applied marker to prevent double-awards
  xpAppliedAt DateTime?
}

model PointsLedger {
  id String @id @default(cuid())

  churchId String
  church   Church @relation(fields: [churchId], references: [id], onDelete: Cascade)

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  type   LedgerType
  amount Int

  meta Json?

  createdAt DateTime @default(now())

  @@index([churchId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
}

model ShopCatalogItem {
  /// Unique key referenced by the mobile catalog.json
  /// Example: "hat_baseball_red"
  itemKey String

  churchId String
  church   Church @relation(fields: [churchId], references: [id], onDelete: Cascade)

  isActive Boolean @default(true)
  pricePoints Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([churchId])
  @@index([isActive])

  @@unique([churchId, itemKey])
}

model Inventory {
  id String @id @default(cuid())

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  itemKey String

  quantity Int @default(1)

  acquiredAt DateTime @default(now())

  @@unique([userId, itemKey])
  @@index([userId])
  @@index([itemKey])
}

model XpLedger {
  id        String   @id @default(cuid())
  userId    String
  taskId    String?

  // how much was granted after soft-cap (the actual applied XP)
  xpGranted Int

  // optional: raw base XP before soft-cap (useful for debug)
  xpBase    Int?

  category  XpCategory
  source    XpSource

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  task Task? @relation(fields: [taskId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([userId, source, createdAt])
  @@index([taskId])
}
